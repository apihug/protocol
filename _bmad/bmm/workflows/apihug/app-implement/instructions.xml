<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>üìñ Read the App Development Bible: {bible}</critical>
  <critical>Follow the checklist: {validation}</critical>
  <critical>Respect ApiHug Source Set Convention: generated code in `src/generated/main/{api,domain,wire,mcp,cloud}` (read-only), handwritten code in `src/main/{java,trait,proto}`. NEVER modify src/generated/ - regenerated by `wire` task!</critical>
  <critical>Service implementation MUST follow the same DDD layering and feature-based packaging as proto design: controllers in `src/generated/main/api` stay thin, all business logic goes into `src/main/java` service implementations (e.g., `OrderServiceImpl` under the `order` feature package), using generated request/response types from `src/generated/main/{wire,api}`.</critical>

  <step n="1" goal="Generate code from proto definitions">
    <output>**üîß Phase 1: Code Generation**
    
    Running wire task for: {domain_name}
    Module: {module_gradle_module}
    </output>

    <prerequisites>
      <check>Proto module defined successfully</check>
      <check>hope-wire.json configured at {hope_wire}</check>
    </prerequisites>

    <action>Run command: ./gradlew {module_gradle_module}:wire</action>
        
    <action>Verify generated outputs:
      1. API interfaces in {module_path}/src/generated/main/api/
      2. Domain entities in {module_path}/src/generated/main/domain/
      3. DTOs in {module_path}/src/generated/main/wire/
      4. Repository templates in {module_path}/src/main/trait/
    </action>
        
    <check if="generation failed">
      <output>‚ùå Code generation failed</output>
      <action>Check proto compilation: ./gradlew {module_gradle_module}:compileJava</action>
      <action>Verify hope-wire.json configuration</action>
      <abort/>
    </check>

    <action>Set {{generated_services}} = count of service interfaces in src/generated/main/api/</action>
    <action>Set {{generated_entities}} = count of entities in src/generated/main/domain/</action>
    <action>Set {{generated_repositories}} = count of repositories in trait/</action>

    <output>‚úÖ Code generation complete!
    
    Generated:
    - {{generated_services}} service interfaces
    - {{generated_entities}} domain entities
    - {{generated_repositories}} repository templates
    </output>
  </step>

  <step n="2" goal="Analyze generated code and plan implementation">
    <output>**üîç Phase 2: Analysis**
    
    Analyzing generated code to identify implementation requirements...
    </output>

    <action>Load meta index from {module_path}/src/main/resources/apihug.idx.csv (if exists) and use rows where type = "Service" as the authoritative list of services to implement. For each row, take the `class` value (e.g., `com.arken.aip.api.aftersales.AfterSalesService`) as the service interface FQCN.</action>
    <action>For each such service FQCN, derive the expected implementation class in src/main/java using the SAME package and appending `Impl` to the simple name (e.g., `com.arken.aip.api.aftersales.AfterSalesServiceImpl` at {module_path}/src/main/java/com/arken/aip/api/aftersales/AfterSalesServiceImpl.java). These ServiceImpl classes are the ONLY entry points you should implement in Phase 3 (replace builder.notImplemented()).</action>

    <action>Load all service interfaces from {module_path}/src/generated/main/api/**/*Service.java</action>
    <action>For each service interface:
      1. Extract method signatures
      2. Note input/output DTO types
      3. Identify dependencies (repositories, other services)
      4. Record in {{service_methods}} list
    </action>

    <action>Load all entities from {module_path}/src/generated/main/domain/**/*Entity.java</action>
    <action>For each entity:
      1. Note field names and types
      2. Check for traits: AUDITABLE, DELETABLE, TENANT_ISOLATE
      3. Identify relationships (foreign keys)
      4. Record in {{entity_analysis}} list
    </action>

    <action>Load repository templates from {module_path}/src/main/trait/**/*Repository.java</action>
    <action>For each repository:
      1. Check if custom queries needed
      2. Plan SQL extensions
      3. Record in {{repository_extensions}} list
    </action>

    <output>**üìã Implementation Plan**
    
    Services to implement: {{service_methods.count}}
    {{#each service_methods}}
      - {{interface_name}}.{{method_name}}({{params}}) ‚Üí {{return_type}}
    {{/each}}
    
    Entities available: {{entity_analysis.count}}
    {{#each entity_analysis}}
      - {{entity_name}} ({{field_count}} fields, traits: {{traits}})
    {{/each}}
    
    Repository extensions needed: {{repository_extensions.count}}
    {{#each repository_extensions}}
      - {{repository_name}}: {{custom_query_description}}
    {{/each}}
    </output>

    <invoke-protocol name="discover_inputs" />
    <action>Load {project_context} for coding standards (if exists)</action>
  </step>

  <step n="3" goal="Implement service business logic">
    <critical>NEVER modify src/generated/ or any generated code - only write code in src/main/java/</critical>
    <critical>Service Impl templates in src/main/java already exist with method stubs calling builder.notImplemented() - your job is to REPLACE that placeholder with real business logic, then call builder.payload(response).done()</critical>
    
    <output>**üíº Phase 3: Service Implementation**
    
    Location: {impl_path}/{package_name}/**/*ServiceImpl.java (already exists from stub generation)
    Pattern: Replace builder.notImplemented() with business logic + builder.payload(response).done()
    </output>

    <ask>Ready to implement services? Choose an option:
    
    1. **Implement all services** - Replace all {{service_methods.count}} placeholder methods
    2. **Implement specific service** - Specify service name
    3. **Show implementation guidance** - Display patterns and best practices
    4. **Skip for now** - Move to next phase
    
    Choose [1], [2], [3], or [4]:</ask>

    <check if="user chooses 1">
      <action>For each service implementation in src/main/java/**/service/impl/*ServiceImpl.java:
        1. Locate method with builder.notImplemented() placeholder
        2. Replace placeholder with:
           - Business logic implementation
           - Create response object
           - Call builder.payload(response).done()
        3. Add @Transactional annotation for data modifications
        4. NO input validation needed (already done in controller layer)
      </action>
      <action>Set {{implemented_services}} = {{service_methods.count}}</action>
      <output>‚úÖ Implemented {{implemented_services}} service methods</output>
    </check>

    <check if="user chooses 2">
      <ask>Enter service name (e.g., OrganizationService):</ask>
      <action>Set {{target_service}} = user input</action>
      <action>Locate {impl_path}/**/{{target_service}}Impl.java</action>
      <action>Replace builder.notImplemented() with business logic</action>
      <output>‚úÖ Implemented {{target_service}}Impl methods</output>
    </check>

    <check if="user chooses 3">
      <output>**üéì Service Implementation Pattern**

**Stub-generated template (DO NOT CREATE - already exists)**:
```java
@Service
public class OrganizationServiceImpl implements OrganizationService {
  /**
   * Authorization:
   * <ul>
   *   <li>Authorities: [ORG_DEPT_CREATE]</li>
   * </ul>
   * @apiNote
   *   <p>{@code /api/organization/departments}
   *   <p>{@code ÂàõÂª∫ÈÉ®Èó® ÂàõÂª∫Êñ∞ÁöÑÈÉ®Èó®‰ø°ÊÅØ}
   */
  @Override
  public void createDepartment(SimpleResultBuilder<CreateDepartmentResponse> builder,
      CreateDepartmentRequest createDepartmentRequest) {
    builder.notImplemented();  // ‚Üê REPLACE THIS
  }
}
```

**Your implementation (REPLACE builder.notImplemented())**:
```java
@Service
public class OrganizationServiceImpl implements OrganizationService {
  private final DepartmentRepository departmentRepository;
  
  // Constructor injection
  public OrganizationServiceImpl(DepartmentRepository departmentRepository) {
    this.departmentRepository = departmentRepository;
  }
  
  @Override
  @Transactional  // Add if modifying data
  public void createDepartment(SimpleResultBuilder<CreateDepartmentResponse> builder,
      CreateDepartmentRequest createDepartmentRequest) {
    // 1. Business logic (NO validation - controller already did it)
    DepartmentEntity entity = new DepartmentEntity();
    entity.setDeptName(createDepartmentRequest.getDeptName());
    entity.setDeptCode(createDepartmentRequest.getDeptCode());
    
    DepartmentEntity saved = departmentRepository.save(entity);
    
    // 2. Build response
    CreateDepartmentResponse response = new CreateDepartmentResponse();
    response.setDeptId(saved.getId());
    response.setDeptCode(saved.getDeptCode());
    
    // 3. Set payload and done
    builder.payload(response).done();
  }
}
```

**Guidelines**:
- ‚úÖ Use constructor injection (already in stub template)
- ‚úÖ Add @Transactional for data modifications
- ‚úÖ Replace builder.notImplemented() with: business logic + builder.payload(response).done()
- ‚úÖ Throw domain exceptions from proto definitions
- ‚ùå NO input validation (controller layer handles it)
- ‚ùå Never modify src/generated/main/{api,domain,wire} or any generated directories
      </output>
      <action>Return to service implementation choice</action>
    </check>

    <check if="user chooses 4">
      <output>‚è≠Ô∏è Skipping service implementation</output>
    </check>

    <validation>
      <check>All builder.notImplemented() replaced with real logic</check>
      <check>All methods call builder.payload(response).done()</check>
      <check>Constructor injection used (no field injection)</check>
      <check>@Transactional applied to data modifications</check>
      <check>No input validation in service layer</check>
    </validation>
  </step>

  <step n="4" goal="Extend repositories with custom queries" optional="true">
    <output>**üóÑÔ∏è Phase 4: Repository Extension (Optional)**
    
    Location: {trait_path}
    Pattern: Custom SQL in _DerivedSQL interface
    </output>

    <check if="{{repository_extensions.count}} == 0">
      <output>‚ÑπÔ∏è No custom repository extensions needed - skipping</output>
      <action>Jump to step 5</action>
    </check>

    <ask>Extend repositories with custom queries? Choose:
    
    1. **Generate extensions** - Add custom query methods
    2. **Show pattern** - Display repository extension pattern
    3. **Skip** - Use generated repositories as-is
    
    Choose [1], [2], or [3]:</ask>

    <check if="user chooses 1">
      <action>For each repository in {{repository_extensions}}:
        1. Locate {trait_path}/_{{repository_name}}.java
        2. Add custom methods in _DerivedSQL interface
        3. Use @Query annotation for SQL
        4. Semantic method names (e.g., findByCustomCriteria)
      </action>
      <output>‚úÖ Extended {{repository_extensions.count}} repositories</output>
    </check>

    <check if="user chooses 2">
      <output>**üéì Repository Extension Pattern**

```java
@Repository
public interface {{Entity}}Repository {
}

interface _{{Entity}}Repository extends {{Entity}}Repository {
    /**
     * Please put your customized SQL here, any SQL other place will be dropped after merger!
     */
    interface _DerivedSQL {
        @Query("SELECT * FROM {{table}} WHERE {{condition}}")
        List&lt;{{Entity}}&gt; findByCustomCriteria(@Param("param") Type param);
        
        @Query("SELECT COUNT(*) FROM {{table}} WHERE {{condition}}")
        long countByCustomCriteria(@Param("param") Type param);
    }
}
```

**Guidelines**:
- ‚úÖ Custom SQL **must** be in _DerivedSQL interface
- ‚úÖ Use @Query annotations with named parameters
- ‚úÖ Semantic method names
- ‚úÖ For complex queries, use JdbcTemplate in service layer
      </output>
      <action>Return to repository extension choice</action>
    </check>

    <validation>
      <check>Custom queries in _DerivedSQL interface only</check>
      <check>@Query annotations present</check>
      <check>Named parameters used</check>
    </validation>
  </step>

  <step n="5" goal="Add application configuration" optional="true">
    <output>**‚öôÔ∏è Phase 5: Configuration (Optional)**
    
    Location: {impl_path}/{package_name}/config/
    </output>

    <ask>Add application-specific configuration? [yes/no/show-pattern]</ask>

    <check if="user says yes">
      <ask>What type of configuration?
      
      1. **Application properties** - Type-safe @ConfigurationProperties
      2. **Bean definitions** - Custom Spring beans
      3. **Profile-specific** - Environment-specific settings
      
      Choose or describe:</ask>
      
      <action>Generate configuration class based on user choice</action>
      <output>‚úÖ Configuration added</output>
    </check>

    <check if="user says show-pattern">
      <output>**üéì Configuration Pattern**

```java
@Configuration
@ConfigurationProperties(prefix = "app")
public class AppConfig {
    private String property;
    private int maxSize;
    
    // Getters and setters
}
```

**Guidelines**:
- ‚úÖ Use @ConfigurationProperties for type safety
- ‚úÖ No Spring Security configuration needed (ApiHug doesn't use it)
- ‚úÖ Use Spring Profiles for environment-specific settings
- ‚úÖ Validate configuration with @Validated
      </output>
    </check>

    <check if="user says no">
      <output>‚è≠Ô∏è Skipping configuration</output>
    </check>
  </step>

  <step n="6" goal="Write comprehensive tests">
    <output>**üß™ Phase 6: Testing**
    
    Coverage target: > 80%
    </output>

    <ask>Write tests? Choose:
    
    1. **Generate all tests** - Service + repository tests
    2. **Service tests only** - Test business logic
    3. **Repository tests only** - Test custom queries
    4. **Show patterns** - Display test patterns
    5. **Skip** - No tests for now
    
    Choose [1-5]:</ask>

    <check if="user chooses 1 or 2">
      <action>For each implemented service:
        1. Create {test_path}/{package_name}/service/{{ServiceName}}Test.java
        2. Add @SpringBootTest annotation
        3. Mock dependencies with @MockBean
        4. Generate test methods for each service method:
           - Given: Setup test data
           - When: Execute method
           - Then: Verify results and behavior
        5. Include edge case tests
      </action>
      <output>‚úÖ Generated service tests</output>
    </check>

    <check if="user chooses 1 or 3">
      <action>For each extended repository:
        1. Create {test_path}/{package_name}/repository/{{Repository}}Test.java
        2. Add @DataJdbcTest annotation
        3. Test custom query methods
        4. Verify SQL correctness
      </action>
      <output>‚úÖ Generated repository tests</output>
    </check>

    <check if="user chooses 4">
      <output>**üéì Test Patterns**

**Service Test**:
```java
@SpringBootTest
class {{ServiceName}}Test {
    @Autowired {{ServiceName}} service;
    @MockBean {{Entity}}Repository repository;
    
    @Test
    void testCreate{{Entity}}Success() {
        // Given
        {{Request}} request = build{{Request}}();
        {{Entity}} entity = build{{Entity}}();
        when(repository.save(any())).thenReturn(entity);
        
        // When
        {{Response}} response = service.create{{Entity}}(request);
        
        // Then
        assertNotNull(response);
        assertEquals(expected, response.getData());
        verify(repository).save(any());
    }
    
    @Test
    void testCreate{{Entity}}WithNullRequest() {
        // When/Then
        assertThrows(IllegalArgumentException.class, 
            () -> service.create{{Entity}}(null));
    }
}
```

**Repository Test**:
```java
@DataJdbcTest
class {{Entity}}RepositoryTest {
    @Autowired {{Entity}}Repository repository;
    
    @Test
    void testFindByCustomCriteria() {
        // Given
        {{Entity}} entity = build{{Entity}}();
        repository.save(entity);
        
        // When
        List&lt;{{Entity}}&gt; results = repository.findByCustomCriteria(criteria);
        
        // Then
        assertFalse(results.isEmpty());
        assertEquals(entity.getId(), results.get(0).getId());
    }
}
```
      </output>
      <action>Return to test choice</action>
    </check>

    <check if="user chooses 5">
      <output>‚è≠Ô∏è Skipping tests (not recommended)</output>
    </check>

    <validation>
      <check>Service tests cover all methods</check>
      <check>Repository tests verify custom queries</check>
      <check>Edge cases tested</check>
      <check>Test coverage > 80%</check>
    </validation>
  </step>

  <step n="7" goal="Verify application runs correctly">
    <output>**‚úÖ Phase 7: Verification**
    
    Starting application to verify implementation...
    </output>

    <action>Run command: ./gradlew {module_gradle_module}:bootRun</action>
    
    <action>Wait for application startup (check for "Started Application" in logs)</action>

    <check if="application fails to start">
      <output>‚ùå Application failed to start</output>
      <action>Check error logs for:
        - Bean creation errors
        - Configuration issues
        - Missing dependencies
        - Database connection problems
      </action>
      <ask>Fix issues and retry? [yes/no]</ask>
    </check>

    <action>Verify endpoints accessible:
      1. http://localhost:18899/ - Application root
      2. http://localhost:18899/v3/api-docs - OpenAPI Specification
      3. http://localhost:18899/management - Actuator endpoints
      4. http://localhost:18899/hope/meta/errors - Error codes
      5. http://localhost:18899/hope/meta/authorities - Authority definitions
    </action>

    <output>**üîç Verification Checklist**
    
    ‚úÖ Application started successfully
    ‚úÖ OpenAPI documentation accessible at http://localhost:18899/v3/api-docs
    ‚úÖ Actuator endpoints responding at http://localhost:18899/management
    ‚úÖ Error codes exposed at http://localhost:18899/hope/meta/errors
    ‚úÖ Authorities accessible at http://localhost:18899/hope/meta/authorities
    
    **Next Steps**:
    - Test API functionality with curl/Postman
    - Review OAS documentation accuracy
    - Verify error handling
    </output>

    <ask>Test API endpoints now? [yes/show-examples/no]</ask>

    <check if="user says yes or show-examples">
      <output>**üì° API Testing Examples**

```bash
# List all APIs
curl http://localhost:18899/v3/api-docs | jq '.paths'

# Test create endpoint
curl -X POST http://localhost:18899/api/{{resource}} \
  -H "Content-Type: application/json" \
  -d '{{sample_request}}'

# Test list endpoint
curl http://localhost:18899/api/{{resource}}

# Test get by ID
curl http://localhost:18899/api/{{resource}}/{{id}}
```
      </output>
    </check>

    <validation>
      <check>Application starts without errors</check>
      <check>OAS documentation accessible</check>
      <check>API endpoints respond correctly</check>
      <check>Error codes properly exposed</check>
      <check>Authorities defined</check>
    </validation>
  </step>

  <step n="8" goal="Generate implementation summary">
    <output>**üìù Phase 8: Documentation**
    
    Generating implementation summary...
    </output>

    <action>Collect implementation details:
      - Implemented services: {{implemented_services}}
      - Extended repositories: {{repository_extensions.count}}
      - Configuration classes: {{config_classes.count}}
      - Test coverage: {{test_coverage}}%
    </action>

    <action>Generate summary document at {default_output_file}</action>

    <output file="{module_path}/docs/app-implement-{{domain_name}}-{{module_name}}.md">
# {{module_name}} Implementation Summary

**Domain**: {{domain_name}}
**Application**: {{application_name}}
**Date**: {{date}}
**Developer**: {{user_name}}

## üì¶ Module Information

- **Module**: {{module_gradle_module}}
- **Package**: {{package_name}}

## ‚úÖ Implementation Completed

### Services Implemented ({{implemented_services}})
{{#each service_methods}}
- `{{interface_name}}Impl`
  - {{method_name}}({{params}}) ‚Üí {{return_type}}
{{/each}}

### Repository Extensions ({{repository_extensions.count}})
{{#each repository_extensions}}
- `{{repository_name}}`: {{custom_query_description}}
{{/each}}

### Configuration Classes ({{config_classes.count}})
{{#each config_classes}}
- `{{class_name}}`: {{description}}
{{/each}}

## üß™ Test Coverage

- **Service Tests**: {{service_test_count}} classes
- **Repository Tests**: {{repository_test_count}} classes
- **Overall Coverage**: {{test_coverage}}%

## üîç Verification

- [x] Application starts successfully
- [x] OpenAPI documentation accessible
- [x] API endpoints respond correctly
- [x] Error codes exposed
- [x] Authorities defined

## üìö References

- [Development Bible]({bible})
- [Implementation Checklist]({validation})
- [Wire Configuration]({hope_wire})

## üöÄ Next Steps

1. Review OAS documentation for accuracy
2. Test all API endpoints thoroughly
3. Add integration tests if needed
4. Update domain documentation
5. Prepare for deployment
    </output>

    <output>‚úÖ **Implementation Complete!**
    
    Summary saved to: {module_path}/docs/app-implement-{{domain_name}}-{{module_name}}.md
    
    **Statistics**:
    - Services implemented: {{implemented_services}}
    - Repositories extended: {{repository_extensions.count}}
    - Test coverage: {{test_coverage}}%
    
    **Application running at**: http://localhost:18899
    </output>
  </step>

</workflow>
