<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>üìñ Read the Proto Design Bible: {bible}</critical>
  <critical>Follow the three specs: Constant, Domain, Swagger (includes Mock)</critical>
  <critical>ALL proto field names MUST use snake_case (e.g., user_name, created_at). NEVER use camelCase or PascalCase for proto fields (e.g., userName, username, createdAt, userId).</critical>
  <critical>Proto imports: ONLY import proto files that are ACTUALLY USED in current file. DO NOT blindly import all ApiHug proto files. Import on-demand based on which options/types are referenced.</critical>
  <critical>Proto layering isolation: API layer (api/) MUST NOT import domain entities (domain/). Domain layer (domain/) MUST NOT import API messages (api/). Constants (infra/) can be shared across layers. This ensures strict architectural boundaries.</critical>
  <critical>ALL proto package names and directory segments MUST be valid Java package identifiers: lower-case letters and digits only, starting with a letter, separated by dots. NEVER use underscores, hyphens, uppercase letters, or leading digits in package segments (e.g., use com.easy.order.customerpoint.api, NOT com.easy.order.customer_point.api).</critical>
  <critical>NEVER generate any file-level "option ..." declarations in proto files (e.g., option java_package, option java_multiple_files, option go_package). Rely on default codegen settings; all such options are strictly forbidden in generated proto.</critical>
  <critical>Proto type naming convention (MUST):
    - Error code enums end with "Errors" (e.g., UserErrors)
    - Business enums end with "Enums" (e.g., OrderStatusEnums)
    - Entity messages end with "Entity" (e.g., UserEntity)
    - API services end with "Service" (e.g., UserService)
  </critical>
  <critical>Feature self-containment (DDD-friendly): For each sub-feature/module (e.g., "order"), design a COMPLETE set of proto components **within that feature**: its own APIs, entities, enums and errors. Do NOT scatter one feature's APIs/entities/errors into other feature packages. Truly shared settings (e.g., global authority enums/errors) stay only in the root-level infra/settings package.</critical>
  <critical>Respect ApiHug Source Set Convention: generated code in `src/generated/main/{api,domain,wire,mcp,cloud}` (read-only), handwritten code in `src/main/{java,trait,proto}`. NEVER modify src/generated/ - regenerated by `wire` task!</critical>

  <step n="1" goal="Load project context and identify domain">
    <output>**üîç Phase 1: Project Context Loading**

    Loading domain configuration and existing proto structure...
    </output>

    <action>Attempt to read {hope_wire} configuration file</action>

    <check if="hope-wire.json exists">
      <action>Parse configuration:
        - packageName: {{package_name}}
        - domain: {{domain_name}}
        - application: {{application_name}}
        - artifact.groupId: {{artifact_group_id}}
        - artifact.artifactId: {{artifact_artifact_id}}
        - authority.enumClass: {{authority_enum_class}}
      </action>
      <output>‚úÖ Domain configuration loaded: {{domain_name}}</output>
    </check>

    <check if="hope-wire.json NOT exists OR domain field missing">
      <output>‚ö†Ô∏è Domain configuration not found or incomplete</output>

      <ask>Please provide domain information:

      1. **List available domains** - Show all domains in this project
      2. **Specify domain manually** - Enter domain name directly
      3. **Scan project** - Auto-detect domains from settings.gradle

      Choose [1], [2], or [3]:</ask>

      <check if="user chooses 1">
        <ask>Enter available domains (comma-separated, e.g., order,customer,product):</ask>
        <action>Set {{available_domains}} = user input split by comma</action>
        <ask>Which domain are you designing for? Choose from: {{available_domains}}</ask>
        <action>Set {{domain_name}} = user selection</action>
      </check>

      <check if="user chooses 2">
        <ask>Enter domain name (e.g., order):</ask>
        <action>Set {{domain_name}} = user input</action>
        <ask>Enter module name (e.g., order-app):</ask>
        <action>Set {{module_name}} = user input</action>
      </check>

      <check if="user chooses 3">
        <action>Run: grep -r "include" {project-root}/settings.gradle</action>
        <action>For each included module:
          1. Check if {project-root}/{{module}}/src/main/resources/hope-wire.json exists
          2. If exists, extract domain name from hope-wire.json
        </action>
        <action>Set {{available_domains}} = extracted domain names from modules with hope-wire.json</action>
        <output>Found domains: {{available_domains}}</output>
        <ask>Select domain: {{available_domains}}</ask>
        <action>Set {{domain_name}} = user selection</action>
      </check>

      <action>Load hope-wire.json from the selected module's resources directory</action>
    </check>

    <action>Load proto module meta index (if exists, generated from previous build):
      - {meta_index}: Compressed components and entities index in CSV format
      Note: This CSV file is auto-generated after proto:build, providing complete module snapshot with minimal token overhead
    </action>

    <check if="meta index exists">
      <action>Parse apihug.idx.csv:
        - CSV columns: type, class, name, description, proto, details
        - Count components by type:
          * Services: filter rows where type='Service' ‚Üí {{existing_services}}
          * APIs: for each Service row, split details column by '|' and count ‚Üí sum = {{existing_apis}}
          * Components: filter rows where type='Component' ‚Üí {{existing_components}}
          * Enums: filter rows where type='Enum' ‚Üí {{existing_enums}}
          * Errors: filter rows where type='Error' ‚Üí {{existing_errors}}
          * Tables: filter rows where type='Table' ‚Üí {{existing_entities}}
        - Extract package info from any Service/Component row's proto column path if needed
      </action>
    </check>

    <check if="meta index NOT exist">
      <output>‚ö†Ô∏è Meta index not found - this might be a new proto module or not yet compiled</output>
      <action>Set {{existing_enums}} = 0</action>
      <action>Set {{existing_errors}} = 0</action>
      <action>Set {{existing_services}} = 0</action>
      <action>Set {{existing_apis}} = 0</action>
      <action>Set {{existing_components}} = 0</action>
      <action>Set {{existing_entities}} = 0</action>
    </check>

    <output>**üìã Project Context Summary**

    **Domain**: {{domain_name}}
    **Package**: {{package_name}}
    **Module**: {{module_name}}
    **Application**: {{application_name}}

    **Existing Components** (from compiled meta index):
    - Services: {{existing_services}}
    - APIs: {{existing_apis}}
    - Domain Entities: {{existing_entities}}
    - Components: {{existing_components}}
    - Enums: {{existing_enums}}
    - Errors: {{existing_errors}}

    **Specifications Available**:
    üìÑ Constant.md (Enums & Errors) - Load when designing constants
    üìÑ Domain.md (Entities & Views) - Load when designing entities
    üìÑ Swagger.md (API Design & Mock) - Load when designing APIs
    </output>

    <invoke-protocol name="discover_inputs" />
    <action>Load {project_context} for additional coding standards (if exists)</action>
  </step>

  <step n="2" goal="Clarify business requirements">
    <output>**üí° Phase 2: Requirements Clarification**

    Choose your input approach based on what you have:
    </output>

    <ask>What type of input will you provide?

    A. **Story/PRD/Design Doc** - I will analyze it and propose complete design
    B. **Natural Language Requirement** - Describe what you want (e.g., "user login system")
    C. **Precise Instruction** - Direct specification (e.g., "API: Login, input: user_name, password")

    Choose [A/B/C]:</ask>

    <check if="user chooses A">
      <ask>Provide design source:
      1. BMAD dev-story file path
      2. PRD/Story markdown file path
      3. Paste story/PRD text directly
      </ask>

      <action>Set {{requirements_source}} = user input</action>
      <action>If {{requirements_source}} looks like file path, load COMPLETE file; otherwise treat as raw text</action>

      <action>Analyze document to extract structured design:
        - Parse Story/Context, Acceptance Criteria, Business Rules
        - Identify candidate APIs: look for "provide/expose/call" patterns ‚Üí service + rpc + request/response
        - Identify candidate Entities: look for "save/record/table/database" patterns ‚Üí table + columns + wires
        - Identify candidate Enums: look for "status/type/category" with limited values
        - Identify candidate Errors: look for "error/failure/unauthorized/validation" patterns
        - Infer fields, types, constraints from context
      </action>

      <output>**üìã Proposed Design from Document Analysis**

      **APIs**:
      {{#each proposed_apis}}
      - {{service}}.{{rpc}}: {{http_method}} {{path}}
        Input: {{input_fields}}
        Output: {{output_fields}}
        Errors: {{error_scenarios}}
        Auth: {{required_permissions}}
      {{/each}}

      **Entities**:
      {{#each proposed_entities}}
      - {{name}}: {{fields}} (wires: {{wires}})
      {{/each}}

      **Enums**:
      {{#each proposed_enums}}
      - {{name}}: {{values}}
      {{/each}}

      **Errors**:
      {{#each proposed_errors}}
      - {{name}} ({{code}}): {{message}}
      {{/each}}

      **Design Rationale**:
      {{design_reasoning}}
      </output>

      <ask>Review proposed design:

      A. **Confirm** - Generate proto with this design
      B. **Adjust** - Tell me what to change (e.g., "add created_at field to User entity")
      C. **Redesign** - Start over with different approach

      Choose [A/B/C] or describe adjustments:</ask>

      <check if="user chooses A">
        <action>Set {{final_design}} = {{proposed_design}}</action>
      </check>

      <check if="user chooses B">
        <action>Parse user adjustments and merge into {{proposed_design}}</action>
        <output>**Updated Design**
        (show updated design)
        </output>
        <ask>Confirm updated design? [Y/n]</ask>
        <action>Set {{final_design}} = {{updated_design}}</action>
      </check>

      <check if="user chooses C">
        <action>Return to input type selection</action>
      </check>
    </check>

    <check if="user chooses B">
      <ask>Describe your feature requirement in natural language:

      Example:
      - "ÂàõÂª∫Áî®Êà∑ÁôªÂΩïÁ≥ªÁªüÔºåÊîØÊåÅÁî®Êà∑ÂêçÂØÜÁ†ÅÁôªÂΩïÔºåËÆ∞ÂΩïÁôªÂΩïÂéÜÂè≤"
      - "ËÆ¢ÂçïÁÆ°ÁêÜÊ®°ÂùóÔºåÂåÖÂê´ÂàõÂª∫ËÆ¢Âçï„ÄÅÊü•ËØ¢ËÆ¢Âçï„ÄÅÂèñÊ∂àËÆ¢ÂçïÂäüËÉΩ"
      - "ÂïÜÂìÅÂ∫ìÂ≠òÁÆ°ÁêÜÔºåÊîØÊåÅÂÖ•Â∫ì„ÄÅÂá∫Â∫ì„ÄÅÁõòÁÇπ"

      Your requirement:</ask>

      <action>Set {{natural_language_requirement}} = user input</action>

      <action>Infer complete design from natural language:
        1. Identify core domain concepts (nouns ‚Üí entities)
        2. Identify actions/operations (verbs ‚Üí APIs)
        3. Identify states/categories (adjectives ‚Üí enums)
        4. Identify error scenarios (failure cases ‚Üí error codes)
        5. Infer fields based on domain knowledge:
           - User entity ‚Üí user_name, email, password_hash, status, created_at
           - Login API ‚Üí input(user_name, password), output(access_token, user_id)
           - LoginHistory entity ‚Üí user_id, login_time, ip_address, success
        6. Apply domain best practices (e.g., add AUDITABLE wire, include error codes)
      </action>

      <output>**ü§ñ AI-Generated Design**

      **APIs**:
      {{#each inferred_apis}}
      - {{service}}.{{rpc}}: {{http_method}} {{path}}
        Input: {{input_fields}}
        Output: {{output_fields}}
      {{/each}}

      **Entities**:
      {{#each inferred_entities}}
      - {{name}}: {{fields}}
      {{/each}}

      **Enums & Errors**:
      {{#each inferred_constants}}
      - {{name}}: {{values}}
      {{/each}}

      **Inference Rationale**:
      {{inference_reasoning}}
      </output>

      <ask>Review AI-generated design:

      A. **Confirm** - Generate proto with this design
      B. **Adjust** - Tell me what to change
      C. **Ask Questions** - I need more information from you

      Choose [A/B/C] or describe adjustments:</ask>

      <check if="user chooses A">
        <action>Set {{final_design}} = {{inferred_design}}</action>
      </check>

      <check if="user chooses B">
        <action>Parse adjustments and update design</action>
        <output>**Updated Design**</output>
        <ask>Confirm? [Y/n]</ask>
        <action>Set {{final_design}} = {{updated_design}}</action>
      </check>

      <check if="user chooses C">
        <ask>What additional information do you need?
        (I will ask clarifying questions to refine the design)
        </ask>
        <action>Conduct focused Q&A to fill design gaps</action>
        <action>Update design with clarified information</action>
        <output>**Refined Design**</output>
        <ask>Confirm? [Y/n]</ask>
        <action>Set {{final_design}} = {{refined_design}}</action>
      </check>
    </check>

    <check if="user chooses C">
      <ask>Provide precise design instruction:

      Format examples:
      - API: "UserService.Login, POST /auth/login, input: user_name(string), password(string), output: access_token(string), user_id(int64)"
      - Entity: "User, fields: id(int64, pk, auto-inc), user_name(string, 50, unique, not null), email(string, 100, nullable), status(enum: ACTIVE/INACTIVE)"
      - Enum: "UserStatus: UNKNOWN(0), ACTIVE(1), INACTIVE(2), SUSPENDED(3)"
      - Error: "UserError: INVALID_CREDENTIALS(401001, 'Invalid username or password', 'Áî®Êà∑ÂêçÊàñÂØÜÁ†ÅÈîôËØØ', UNAUTHORIZED)"

      Your instruction:</ask>

      <action>Set {{precise_instruction}} = user input</action>

      <action>Parse instruction into structured design:
        - Extract component type (API/Entity/Enum/Error)
        - Extract name, fields, types, constraints
        - Map to proto structure directly
      </action>

      <output>**‚úÖ Parsed Design from Instruction**

      {{parsed_design_summary}}
      </output>

      <ask>Confirm and generate proto? [Y/n]</ask>

      <action>Set {{final_design}} = {{parsed_design}}</action>
    </check>

    <action>From {{final_design}}, derive structured requirement lists:
      1. Set {{api_requirements}} = all API-level design items (services, operations, request/response fields)
      2. Set {{entity_requirements}} = all entity/table design items (including views and indexes)
      3. Set {{constant_requirements}} = all enum and error code design items
      4. Set {{mock_requirements}} = all mock configuration requirements
      Ensure these requirement lists are populated whenever the corresponding parts exist in {{final_design}} so that proto files can be generated in Phase 3.
    </action>

    <output>‚úÖ Requirements clarified and design finalized</output>
  </step>

  <step n="3" goal="Design proto definitions">
    <output>**üé® Phase 3: Proto Definition Design**

    Loading specifications based on design scope...
    </output>

    <check if="{{constant_requirements}} exists">
      <action>Load {spec_constant} for Constant specification (enums/errors design rules)</action>
    </check>

    <check if="{{entity_requirements}} exists">
      <action>Load {spec_domain} for Domain specification (entity/table design rules)</action>
    </check>

    <check if="{{api_requirements}} exists">
      <action>Load {spec_swagger} for Swagger specification (API design rules, includes mock configuration)</action>
    </check>

    <critical>Follow the loaded specs strictly: Constant, Domain, Swagger (see {bible} for full directory/package rules; this step gives only high-level guidance). Mock configuration is embedded within Swagger spec.</critical>

    <output>Generating proto files based on requirements...

    For each target proto file you design, you MUST:
    1. Actually construct the full `.proto` file content (syntax/package/imports/messages/services/options) in memory
    2. Write or update that file at the calculated {file_path} in the workspace
    3. Also include the complete proto content in your response inside a ```proto``` code block so the user can see it
    </output>

    <check if="{{constant_requirements}} exists">
      <action>Calculate target file path:
        1. Base path: {proto_infra_path} (which is {proto_output_root}/infra)
        2. DDD feature-based packaging: Group by sub-feature (e.g., "order"), then "settings" subdirectory
        3. Example: if designing "order" feature constants, file should be at:
           {proto_infra_path}/order/settings/constant.proto or error.proto
           Package: {{package_name}}.infra.order.settings
        4. For truly shared constants (e.g., AUTHORITY), use root-level settings:
           {proto_infra_path}/settings/authority.proto
           Package: {{package_name}}.infra.settings
        5. Directory and filename must align with package declaration
      </action>

      <action>For each enum in {{constant_requirements}}:
        1. Create proto message with syntax = "proto3"
        2. Determine feature context from requirement (e.g., "order", "user") or mark as "shared"
        3. Set package based on feature:
           - Feature-specific: {{package_name}}.infra.{{feature}}.settings
           - Shared: {{package_name}}.infra.settings
        4. Import ONLY "apihug/protobuf/extend/constant.proto" (required for hope.constant.field option)
        5. Define enum with values
        6. Add (hope.constant.field) options:
           - code: {{value.code}}
           - message: "{{value.message}}"
           - message2: "{{value.message2}}"
      </action>

      <action>For each error in {{constant_requirements}}:
        1. Create error enum
        2. Add (hope.constant.error) options:
           - code: {{error.code}}
           - message: "{{error.message}}"
           - message2: "{{error.message2}}"
           - http_status_code: {{error.http_status}}
           - category: {{error.category}}
           - severity: {{error.severity}}
      </action>

      <output>üìÑ Generated constant proto files:
      {{#each constant_files}}
      - {{file_path}}
      {{/each}}
      </output>
    </check>

    <check if="{{entity_requirements}} exists">
      <action>Calculate target file path:
        1. Base path: {proto_domain_path} (which is {proto_output_root}/domain)
        2. DDD feature-based packaging: Group by sub-feature (e.g., "order"), then "domain" subdirectory
        3. Example: if designing "order" feature entity, file should be at:
           {proto_domain_path}/order/domain/entity.proto
           Package: {{package_name}}.order.domain
        4. For truly shared entities (rare), use root-level domain:
           {proto_domain_path}/entities/shared_entity.proto
           Package: {{package_name}}.domain.entities
        5. Directory and filename must align with package declaration
      </action>

      <action>For each entity in {{entity_requirements}}:
        1. Create proto message
        2. Determine feature context from requirement (e.g., "order", "user") or mark as "shared"
        3. Set package based on feature:
           - Feature-specific: {{package_name}}.{{feature}}.domain
           - Shared: {{package_name}}.domain
        4. Import ONLY the required protos based on actual usage:
           - "apihug/protobuf/domain/persistence.proto" (ALWAYS required for hope.persistence.table/column)
           - "apihug/protobuf/domain/view.proto" (ONLY if views are defined)
           - "apihug/protobuf/domain/annotations.proto" (ONLY if using field-level annotations beyond persistence)
        5. Add (hope.persistence.table) option:
           - name: "{{entity.table_name}}"
           - description: "{{entity.description}}"
           - wires: [{{entity.wires}}]
        6. For each field:
           - Add (hope.persistence.column) option with:
             * name: "{{field.column_name}}"
             * description: "{{field.description}}"
             * id: {{field.is_primary_key}}
             * generated: {{field.generation_strategy}}
             * nullable: {{field.nullable}}
             * unique: {{field.unique}}
             * length: {{field.length}}
      </action>

      <action>For each view in {{entity_views}}:
        1. Create view message: {{entity_name}}{{view_type}}View
        2. Add (hope.persistence.view) option:
           - name: "{{view_name}}"
           - description: "{{view_description}}"
           - type: {{view_type}}
        3. Include relevant fields from entity
      </action>

      <output>üìÑ Generated domain proto files:
      {{#each domain_files}}
      - {{file_path}} ({{entity_name}}, {{field_count}} fields)
      {{/each}}
      </output>
    </check>

    <check if="{{api_requirements}} exists">
      <action>Calculate target file path:
        1. Base path: {proto_api_path} (which is {proto_output_root}/api)
        2. DDD feature-based packaging: Group by sub-feature (e.g., "order"), then "api" subdirectory
        3. Example: if designing "order" feature API, file should be at:
           {proto_api_path}/order/api/api.proto
           Package: {{package_name}}.order.api
        4. For truly shared APIs (rare), use root-level api:
           {proto_api_path}/common/api.proto
           Package: {{package_name}}.api.common
        5. Directory structure must match package declaration
      </action>

      <action>For each API in {{api_requirements}}:
        1. Create service definition if not exists
        2. Determine feature context from requirement (e.g., "order", "user") or mark as "shared"
        3. Set package based on feature:
           - Feature-specific: {{package_name}}.{{feature}}.api
           - Shared: {{package_name}}.api
        4. Import protos based on actual usage:
           - "apihug/protobuf/swagger/swagger.proto" (ALWAYS required for hope.swagger.* options)
           - Enums/Errors from same feature: "../settings/*.proto" (relative import)
           - NEVER import domain entities directly (layering violation)
           - Other message types (ONLY if explicitly used)
        5. Add (hope.swagger.svc) option to service:
           - path: "{{service_path}}"
           - description: "{{service_description}}"
           - tag: "{{service_tag}}"
        6. Create rpc method
        7. Add (hope.swagger.operation) option:
           - {{http_method}}: "{{api_path}}"
           - title: "{{api_title}}"
           - description: "{{api_description}}"
           - priority: {{api_priority}}
           - authorize: { roles: [{{required_permissions}}] }
           - pageable: {{needs_pagination}}
           - mock: { enable: TRUE }
        8. Create Request message with fields
        9. Create Response message with fields
      </action>

      <action>For each request/response field:
        1. Add (hope.swagger.schema) option:
           - description: "{{field.description}}"
           - required: {{field.required}}
           - min_length/max_length: {{field.length_constraint}}
           - pattern: "{{field.pattern}}"
           - format: "{{field.format}}"
      </action>

      <output>üìÑ Generated API proto files:
      {{#each api_files}}
      - {{file_path}} ({{api_count}} APIs)
      {{/each}}
      </output>
    </check>

    <check if="{{mock_requirements}} exists">
      <action>For each field in {{mock_fields}}:
        1. Load Swagger spec ({spec_swagger}) to understand mock configuration syntax
        2. Locate or add field-level swagger metadata (`(hope.swagger.field)` or `(hope.swagger.schema)`)
        3. Inside that metadata, add/merge a `mock { ... }` block
        4. Set `mock.nature` = {{field.nature}}
        5. Add specific rule based on type:
           - STRING: `mock.string_rule { min: {{min}}, max: {{max}} }`
           - NUMBER: `mock.number_rule { min: {{min}}, max: {{max}} }`
           - BOOLEAN: `mock.bool_rule { current: {{value}} }`
           - DATE: `mock.date_rule { birth_day: {{days}}, time_gap: {{gap}} }`
           - EMAIL: `mock.nature: EMAIL`
           - URL: `mock.nature: URL`
           - IMAGE: `mock.nature: IMAGE`
           - CHINESE: `mock.chinese_rule { type: {{type}} }`
      </action>

      <output>‚úÖ Mock configurations attached to {{mock_fields.count}} fields</output>
    </check>

    <action>Set {{generated_proto_files}} = list of all created/modified proto files</action>

    <output>**üì¶ Proto Design Complete**

    **Generated Files**: {{generated_proto_files.count}}

    **Breakdown**:
    - Constant/Error: {{constant_files.count}}
    - Domain Entities: {{domain_files.count}}
    - API Definitions: {{api_files.count}}

    **Next**: Compile and verify proto files
    </output>
  </step>

  <step n="4" goal="Compile and verify proto definitions">
    <output>**üî® Phase 4: Compilation & Verification**

    Compiling proto module to verify design...
    </output>

    <action>Run command: ./gradlew {module_gradle_module}:wire -x test</action>

    <action>Monitor compilation output for:
      - Syntax errors
      - Option validation errors
      - Import resolution errors
      - Wire plugin warnings
    </action>

    <check if="compilation fails">
      <output>‚ùå Proto compilation failed</output>

      <action>Parse error messages to identify issues:
        1. Syntax errors ‚Üí Line number and description
        2. Import errors ‚Üí Missing dependencies
        3. Option errors ‚Üí Invalid option values
        4. Package errors ‚Üí Mismatch with hope-wire.json
      </action>

      <output>**üêõ Compilation Errors**

      {{#each compilation_errors}}
      - [{{severity}}] {{file}}:{{line}} - {{message}}
      {{/each}}
      </output>

      <ask>Fix compilation errors? Choose:

      1. **Auto-fix** - Let me attempt to fix the errors
      2. **Show details** - Display full error context
      3. **Manual fix** - I'll fix them manually

      Choose [1-3]:</ask>

      <check if="user chooses 1">
        <action>For each error:
          1. Read proto file
          2. Identify error location
          3. Apply fix based on error type
          4. Update file
        </action>
        <action>Re-compile: ./gradlew {module_gradle_module}:wire</action>
      </check>

      <check if="user chooses 2">
        <action>Display full compilation log with context</action>
        <action>Return to fix choice</action>
      </check>

      <check if="user chooses 3">
        <output>‚ÑπÔ∏è Fix errors manually, then re-run this step</output>
        <abort/>
      </check>
    </check>

    <action>Verify generated code:
      1. Check {module_path}/src/generated/main/wire/ directory (wire command output)
      2. List generated Java classes from proto compilation
      3. Verify class names match proto definitions
      4. Check if error codes are unique
    </action>

    <action>Set {{generated_classes}} = list of generated Java classes from {module_path}/src/generated/main/wire/</action>

    <output>‚úÖ **Compilation Successful**

    **Generated Java Classes**: {{generated_classes.count}}

    **Generated Code Location**:
    - Wire output: src/generated/main/wire/ (proto compilation result)
    - API interfaces: src/generated/main/api/
    - Domain entities: src/generated/main/domain/

    **Key Classes**:
    {{#each generated_classes limit=10}}
    - {{class_name}}
    {{/each}}
    {{#if generated_classes.count gt 10}}
    ... and {{generated_classes.count - 10}} more
    {{/if}}
    </output>

    <action>Validate error codes uniqueness:
      1. Extract all error codes from generated enums
      2. Check for duplicates
    </action>

    <check if="duplicate error codes found">
      <output>‚ö†Ô∏è **Duplicate Error Codes Detected**

      {{#each duplicate_codes}}
      - Code {{code}}: Used in {{enum1}} and {{enum2}}
      {{/each}}

      Fix these conflicts by assigning unique codes.
      </output>
    </check>

    <validation>
      <check>Proto files compile without errors</check>
      <check>Java classes generated in src/generated/main/wire/</check>
      <check>Error codes are unique</check>
      <check>Package names match hope-wire.json</check>
    </validation>
  </step>

  <step n="5" goal="Generate design summary and next steps">
    <output>**üìù Phase 5: Design Summary**

    Creating comprehensive design documentation...
    </output>

    <action>Collect design details:
      - Business requirements
      - Proto files created
      - Generated classes
      - Key design decisions
      - Validation results
    </action>

    <action>Generate summary document at {default_output_file}</action>

    <output file="{module_path}/docs/proto-design-{{domain_name}}-{{module_name}}.md">
# Proto Design Summary

**Domain**: {{domain_name}}
**Module**: {{module_name}}
**Package**: {{package_name}}
**Date**: {{date}}
**Designer**: {{user_name}}

## üìã Business Requirements

### Feature Overview
{{api_description}} / {{entity_description}}

### Functional Requirements
{{#if api_requirements}}
**APIs**:
{{#each api_requirements}}
- **{{name}}**: {{http_method}} {{path}}
  - Description: {{description}}
  - Permissions: {{permissions}}
  - Pagination: {{pagination}}
{{/each}}
{{/if}}

{{#if entity_requirements}}
**Entities**:
{{#each entity_requirements}}
- **{{name}}**: {{field_count}} fields
  - Wires: {{wires}}
  - Views: {{views}}
  - Indexes: {{indexes}}
{{/each}}
{{/if}}

{{#if constant_requirements}}
**Enums/Errors**:
{{#each constant_requirements}}
- **{{name}}**: {{type}} ({{value_count}} values)
{{/each}}
{{/if}}

## üìÑ Proto Files

| File Path | Type | Description |
|-----------|------|-------------|
{{#each generated_proto_files}}
| {{file_path}} | {{type}} | {{description}} |
{{/each}}

## üîë Key Design Decisions

### Constant Design
{{#each constant_requirements}}
- **{{name}}**: {{type}}
  {{#each values}}
  - {{value_name}} ({{code}}): "{{message}}" / "{{message2}}"
  {{/each}}
{{/each}}

### Domain Design
{{#each entity_requirements}}
- **{{name}}**:
  - Table: {{table_name}}
  - Wires: {{wires}}
  - Primary Key: {{primary_key_field}} ({{generation_strategy}})
  - Unique Constraints: {{unique_fields}}
  - Indexes: {{indexes}}
{{/each}}

### API Design
{{#each api_requirements}}
- **{{name}}**: {{http_method}} {{path}}
  - Priority: {{priority}}
  - Authorization: {{roles}}
  - Request: {{request_fields_summary}}
  - Response: {{response_fields_summary}}
  - Errors: {{error_scenarios}}
{{/each}}

### Mock Strategy
{{#if mock_requirements}}
{{#each mock_fields}}
- **{{field_name}}**: {{mock_rule_description}}
{{/each}}
{{/if}}

## ‚úÖ Verification Results

- [x] Proto files compiled successfully
- [x] {{generated_classes.count}} Java classes generated
- [x] Error codes unique (range: {{error_code_range}})
- [x] Mock rules configured
- [x] API paths validated

## üöÄ Next Steps

### 1. Generate Stub Code
```bash
./gradlew {module_gradle_module}:wire -x test
```

This will generate:
- API interfaces in `src/generated/main/api/`
- Domain entities in `src/generated/main/domain/`
- DTOs in `src/generated/main/wire/`
- Repository templates in `src/main/trait/`

### 2. Implement Business Logic
```bash
# Refer to app-implement workflow
{installed_path}/../app-implement/workflow.yaml
```

### 3. Verify Application
```bash
./gradlew {module_gradle_module}:bootRun
```

**Endpoints to verify**:
- Application: http://localhost:18899/
- OpenAPI: http://localhost:18899/v3/api-docs
- Errors: http://localhost:18899/hope/meta/errors
- Authorities: http://localhost:18899/hope/meta/authorities

## üìö References

- [Proto Design Bible]({bible})
- [Constant Spec]({spec_constant})
- [Domain Spec]({spec_domain})
- [Swagger Spec]({spec_swagger})
- [hope-wire.json]({hope_wire})

## üìå Notes

{{#if design_notes}}
{{design_notes}}
{{/if}}

---
*Generated by ApiHug Proto Design Workflow*
    </output>

    <output>‚úÖ **Proto Design Complete!**

    **Summary saved to**: {module_path}/docs/proto-design-{{domain_name}}-{{module_name}}.md

    **Statistics**:
    - Proto files: {{generated_proto_files.count}}
    - Generated classes: {{generated_classes.count}}
    - APIs: {{api_requirements.count}}
    - Entities: {{entity_requirements.count}}
    - Enums/Errors: {{constant_requirements.count}}

    **Next Steps**:
    1. Generate stub code: `./gradlew {module_gradle_module}:wire`
    2. Implement business logic (see app-implement workflow)
    3. Run application: `./gradlew {module_gradle_module}:bootRun`
    </output>

      <ask>What would you like to do next?

    1. **Review proto files** - Show generated proto content
    2. **Continue to implementation** - Switch to app-implement workflow
    3. **Done** - Exit workflow

    Choose [1-3]:</ask>

    <check if="user chooses 1">
      <action>Display content of generated proto files</action>
    </check>

    <check if="user chooses 2">
      <output>Switching to app-implement workflow...</output>
      <action>Load workflow: {installed_path}/../app-implement/workflow.yaml</action>
    </check>

    <check if="user chooses 3">
      <output>üëã Proto design workflow complete!</output>
    </check>
  </step>

</workflow>
